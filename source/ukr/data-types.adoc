ifndef::imagesdir[:imagesdir: ../../imgs]
ifndef::datatypedir[:datatypedir: ../../examples/src/main/java]
ifndef::datatypetestdir[:datatypetestdir: ../../examples/src/test/java]

[#java-data-types]
=== Data types
Типи даних в Java поділяються на примітиви та силочні. Нижче приведен повний список типів даних в Java:

* <<java-data-types-byte, `(Byte)byte`>>
* <<java-data-types-short, `(Short)short`>>
* <<java-data-types-integer, `(Integer)int`>>
* <<java-data-types-string, `String`>>
* `long`
* `float`
* `double`
* `boolean`
* `char`

Далі ми на кожней з них більш детальніше.

Значення змінних за замовченням:

* Числа ініціалізуються `0` або `0.0`;
* `char` — `\u0000`;
* `boolean` — `false`;
* Об'єкти — `null`.

[source,java]
----
include::{datatypedir}/DataType.java[tags=DataType]
----

Локальні змінні треба ініціалізувати одразу при створені шнакше компілятор видасть помилку `java: variable a might not have been initialized`.

Операції з деякими зміними можуть бути не атомарними, наприклад `double` та `long`, можуть записуватись в два кроки, спочатку старші а потім молодші біти. Для запобігання цього можна використати `volatile`.

Так же может бить случаи overflow/underflow проблем, це помилка присвоенная змінній значення більше допустимого або меньше відповідно.

include::data-types-boolean.adoc[]

include::data-types-byte.adoc[]

include::data-types-character.adoc[]

:datatypetestdir: ../../examples/src/test/java
include::data-types-double.adoc[]

include::data-types-float.adoc[]

include::data-types-integer.adoc[]

include::data-types-long.adoc[]

include::data-types-short.adoc[]

include::data-types-string.adoc[]

image::cast-type.png[]

image::shellclasses.png[]

=== Autoboxing в Java
*Автоупаковка* - это механизм неявной инициализации объектов классов-оберток (`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`, `Boolean`) значениями соответствующих им исходных примитивных типов (`byte`, `short`, `int`...), без явного использования конструктора класса.

* Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора `=`), либо при передаче примитива в параметры метода (типа класса-обертки).
* Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и `final`-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.
* Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа `byte` в `Short`, без предварительного явного приведения `byte` в `short` вызовет ошибку компиляции.
* Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
** неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования `int` в `Byte`, сначала компилятор самостоятельно неявно сужает `int` к `byte`)
** автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
*** присвоение примитива обертке может производится только оператором `=` (нельзя передать такой примитив в параметры метода без явного приведения типов)
*** тип левого операнда не должен быть старше чем `Character`, тип правого не дожен старше, чем `int`:
**** допустимо расширение/сужение `byte` в/из `short`, `byte` в/из `char`, `short` в/из `char` и только сужение `byte` из `int`, `short` из `int`, `char` из `int`. Все остальные варианты требуют явного приведения типов).

Дополнительной особенностью целочисленных классов-оберток созданных автоупаковкой констант в диапазоне `-128 ... +127` является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.
